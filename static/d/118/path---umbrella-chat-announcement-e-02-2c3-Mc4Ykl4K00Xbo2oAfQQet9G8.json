{"data":{"site":{"siteMetadata":{"title":"Engineering Schmengineering","author":"Tim Stewart"}},"markdownRemark":{"id":"b950a7b7-3dcb-50a0-964a-135e825a08ab","excerpt":"For about the past month, my friend Atta and I have been working on\na new project. We’ve wanted to build something together for some time\nbut kept throwing…","html":"<p>For about the past month, my friend Atta and I have been working on\na new project. We’ve wanted to build something together for some time\nbut kept throwing around ideas without actually starting. So finally\nwe just picked one that interested us both, and went for it.</p>\n<p>Umbrella Chat is going to be an end-to-end encrypted chat service built\nas a 12-factor web-app. <a href=\"https://github.com/TimtheStew/umbrella-chat\">Check out the source here!</a></p>\n<h2>The Stack</h2>\n<p>On the back-end, we’re using Apollo Server, for ease of setting up\na GraphQL API, and Sequelize as an ORM tool for our Postgres DB.</p>\n<p>In the front, we’re using webpack to bundle our assets, babel to maintain\ncompatibility, React to display a UI, and Redux to manage our state.</p>\n<p>That all sounds great! Modern and efficient! But what does it mean?</p>\n<p>Well strap in, and let me tell you…</p>\n<h3>Back-End</h3>\n<p><a href=\"https://graphql.org/\">GraphQL</a> is an alternative to traditional RESTful\nAPI’s, developed at facebook. The basic idea behind it is that instead of\nhaving lots of endpoints for very specific queries, you have one\n“smart” endpoint, that delivers just the data the client needs, and in whatever\nmanner they need it. This cuts down on data processing on the front end, and\nmeans you don’t have to write a new query every time your front-end needs a\ndifferent collection of data.</p>\n<p>A GraphQL server is a layer that sits between your front end and your data store(s).\nIt works with three main components: Schemas, Queries, and Resolvers.</p>\n<p>GraphQL’s typed <strong>schemas</strong> and <a href=\"https://www.apollographql.com/docs/apollo-server/essentials/schema#sdl\">Schema Definition Language</a>\nare at the core of how it functions. A schema is how you describe your data and\nit’s types to graphql. SDL offers several scalar types (bools, ints, strings, etc.)\nand some abstractions, like objects, to allow you to define your data in terms\nof types and relationships. For instance a rudimentary Chat definition might\nlook like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type Chat{\n    id: ID\n    name: String\n    users: [String]\n    createdAt: String\n    updatedAt: String\n}</code></pre></div>\n<p>There are other things you’ll probably want to include in schemas, such as extensions\nto the Query and Mutation types, but I won’t get into those here. </p>\n<p><strong>Queries</strong> are how you ask for the data you want, and are store-agnostic! It doesn’t\nmatter where what you need comes from, GraphQL takes care of that for you. They can\nalso take arguments, which plays into that “only the data you need” idea.\nSo lets say I wanted a chat with a particular id, my query might look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query{\n    chat(id: &quot;someUUID&quot;){\n        name\n        users\n        updatedAt\n        createdAt\n    }\n}</code></pre></div>\n<p>Since both queries and schemas don’t care about where things come from, you figure\nsomething has to right? Thats where <strong>resolvers</strong> come in! A resolver does what\nit says on the tin - it resolves abstract queries into concrete data by following\nthe procedures you lay out for it. More simply, it tells GraphQL where and how to look\nfor what it wants.</p>\n<p>GraphQL is really just a specification, and can be implemented in any language. For this\nproject the implementation we’re using is\n<a href=\"https://www.apollographql.com/docs/apollo-server/\">Apollo Server</a> which allows for\neasy set-up and auto-documenting of the API your GraphQL server uses. It also\noffers compatibility with a wide range of sources\n(such as a Postgres DB) and is popular, well-documented and well-maintained. </p>\n<p>For our database, we’re using <a href=\"https://www.postgresql.org/\">PostgreSQL</a>, which\nis an open source object-relational database system. It has an emphasis on\nextensibility and standards compliance, as well as a wide support base, given\nit is the DB of choice for many individuals and organizations. </p>\n<p>For ease of querying our database, we’re using an ORM, or Object Relational Mapping\n(library) called <a href=\"http://docs.sequelizejs.com/\">Sequelize</a>. Sequelize is a\npromise based Javascript ORM, that supports a handful of popular DBs such\nas MySQL, Microsoft SQL Server, <strong>Postgres</strong>, and SQLite. It’s purpose is to hide the\nmechanics of SQL querying behind an object model. So instead of\nwriting a statement like </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT * FROM chats WHERE name = &#39;My Squad&#39; </code></pre></div>\n<p>you would do:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Chat.findAll({\n  where: {\n    name : &#39;My Squad&#39;\n  }\n});</code></pre></div>\n<p>Now, with such a trivial example, it might seem we’ve actually made things\nmore complicated, but as queries grow in demand or generality, they can become quite tricky to write\noptimally, and that is where Sequelize really shines. It means that I don’t\nhave to be a SQL master to use fast queries, and the object model can greatly\nsimplify other more ungainly selections. However, since Sequelize isn’t familiar\nwith the ins and outs of my data, I can’t expect it be as good as an actual SQL master\nat writing queries, but I can expect it to be better than me.</p>\n<p>This object model is how our GraphQL resolvers will return the data they need to.</p>\n<p>Using an ORM allows us to employ some OOP techniques to better manage and define our data,\neven at the database level.</p>\n<p>Also, because it abstracts the DB, we could switch to any other DB supported by\nSequelize down the line without too much hassle. </p>\n<h3>Front-End</h3>","frontmatter":{"title":"New Project! Umbrella Chat - an Encrypted Chat Service","date":"March 20, 2019"}}},"pageContext":{"slug":"/Umbrella-Chat-Announcement/","previous":{"fields":{"slug":"/YFS-Retrospective/"},"frontmatter":{"title":"YFS - A Distributed Filesystem Retrospective - WIP"}},"next":null}}